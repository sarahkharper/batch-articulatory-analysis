function data = TTCD_CL(varargin)%PALDIST  - MVIEW dataproc that computes distance of tongue pellets from palate%%	varargin{1} - data%			{2} - palate%% appends T*CD signals to DATA% mkt 11/01% LG 1/03 modified to retrofit to MAVISdata = varargin{1};%data = AddFields(data);pal = varargin{2};if isempty(pal),	warning('need palate data'); 	return; end;% find indices of tongue pellets within data (all those beginning with 'T')% tn = upper(char({data.NAME}'));tidx = strmatch('T', upper(strvcat({data.NAME})));if isempty(tidx),	error('no tongue trajectories found in data');end;% resample palate to 200 equally spaced intervalspal = pal(:,1:2);			% kill tilt if presentk = [0 ; cumsum(sqrt(sum(diff(pal).^2,2)))];pal = interp1(k,pal,linspace(0,k(end),200));px = pal(:,1)';py = pal(:,2)';paldist = [0; cumsum(sqrt(sum(diff(pal).^2,2)))];nps = length(px);% loop over tongue trajectoriesfor ti = 5:8,	[ns nComps] = size(data(ti).SIGNAL);    	if nComps > 1,% find minimum distance from palate for each sample		dx = repmat(px,ns,1) - repmat(data(ti).SIGNAL(:,1),1,nps);		dy = repmat(py,ns,1) - repmat(data(ti).SIGNAL(:,2),1,nps);		n = length(data) + 1;		% append to end of dataset		data(n).NAME = [data(ti).NAME 'CL'];		data(n).SRATE = data(ti).SRATE;        data(n+1).NAME = [data(ti).NAME 'CD'];		data(n+1).SRATE = data(ti).SRATE;		[s,si] = min(sqrt(dx.^2 + dy.^2),[],2);      % negate (want increasing values to correspond with movement towards palate)%		s = -s;% constriction location is the paldist at the minimum        locs = paldist(si);        if max(pal(:,1)) <10           locs = paldist(end) - paldist(si);        end        data(n).SIGNAL = locs;        minS = min(locs);		maxS = max(locs);		spread = maxS - minS;        data(n).SCALING.TYPE = 'UNIQUE'; 		data(n).SCALING.RANGE  = [minS-spread*2 maxS];	% pad        % invert sign of points that have 'passed through' palate		qi = sub2ind([ns nps], [1:ns]', si);		dx = dx(qi); dy = dy(qi);		th = atan2(dy,dx);		si = find(th < 0);		s(si) = -s(si);		data(n+1).SIGNAL = s;		minS = min(s);		maxS = max(s);		spread = maxS - minS;        data(n+1).SCALING.TYPE = 'UNIQUE'; 		data(n+1).SCALING.RANGE  = [minS-spread*.2 maxS+spread*.2];	% pad		end;end;